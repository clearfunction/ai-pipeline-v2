"""
Node.js API template generator using Fastify + TypeScript.
Generates a production-ready API with comprehensive testing.
"""

from typing import List, Any
from templates.base_template_generator import BaseTemplateGenerator, GeneratedCode


class NodeAPITemplateGenerator(BaseTemplateGenerator):
    """Generates Node.js API projects with Fastify and TypeScript."""
    
    def __init__(self):
        super().__init__('node_api')
    
    def generate_project_scaffold(self, project_name: str, architecture: Any) -> List[GeneratedCode]:
        """Generate complete Node.js API project scaffold."""
        self.logger.info(f"Generating Node.js API project: {project_name}")
        
        project_name = self._sanitize_project_name(project_name)
        generated_files = []
        
        # Generate all scaffold files
        templates = {
            'package.json': self._get_package_json(project_name),
            'tsconfig.json': self._get_tsconfig(),
            '.gitignore': self._get_gitignore(),
            'README.md': self._get_readme(project_name),
            'server.js': self._get_server_js(),
            'src/app.ts': self._get_app_ts(),
            'src/routes/index.ts': self._get_routes_index(),
            'src/routes/users.ts': self._get_routes_users(),
            'src/routes/health.ts': self._get_routes_health(),
            'src/middleware/auth.ts': self._get_middleware_auth(),
            'src/middleware/cors.ts': self._get_middleware_cors(),
            'src/middleware/validation.ts': self._get_middleware_validation(),
            'src/services/userService.ts': self._get_user_service(),
            'src/models/User.ts': self._get_user_model(),
            'src/types/index.ts': self._get_types(),
            'src/utils/logger.ts': self._get_logger(),
            'src/utils/config.ts': self._get_config(),
            'src/utils/database.ts': self._get_database(),
            'tests/unit/userService.test.js': self._get_user_service_test(),
            'tests/unit/middleware.test.js': self._get_middleware_test(),
            'tests/integration/users.test.js': self._get_users_integration_test(),
            'tests/integration/health.test.js': self._get_health_integration_test(),
            'tests/security/auth.test.js': self._get_auth_security_test(),
            'tests/contract/users.contract.test.js': self._get_users_contract_test(),
            'tests/load/load-test.yml': self._get_load_test_config(),
            'jest.config.js': self._get_jest_config(),
            'Dockerfile': self._get_dockerfile(),
            '.dockerignore': self._get_dockerignore(),
            '.env.example': self._get_env_example()
        }
        
        for file_path, content in templates.items():
            generated_files.append(
                self._create_generated_code(file_path, content)
            )
        
        self.logger.info(f"Generated {len(generated_files)} Node.js API files")
        return generated_files
    
    def get_supported_runtime(self) -> str:
        return 'node'
    
    def get_description(self) -> str:
        return 'Node.js API with Fastify + TypeScript and comprehensive testing (Jest + Supertest + Security)'
    
    def _get_package_json(self, project_name: str) -> str:
        """Generate package.json with comprehensive test scripts."""
        return f'''{{
  "name": "{project_name}",
  "version": "1.0.0",
  "description": "Node.js API built with Fastify and TypeScript",
  "main": "server.js",
  "scripts": {{
    "start": "node server.js",
    "dev": "nodemon server.js",
    "build": "tsc",
    "test": "jest",
    "test:unit": "jest tests/unit",
    "test:integration": "jest tests/integration",
    "test:security": "jest tests/security",
    "test:coverage": "jest --coverage",
    "test:watch": "jest --watch",
    "test:contract": "jest tests/contract",
    "test:load": "artillery run tests/load/load-test.yml",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "type-check": "tsc --noEmit",
    "db:migrate": "echo 'Database migrations would run here'",
    "docs:generate": "echo 'API documentation would be generated here'"
  }},
  "keywords": ["api", "fastify", "typescript", "nodejs"],
  "author": "Generated by AI Pipeline",
  "license": "MIT",
  "dependencies": {{
    "fastify": "^4.26.2",
    "@fastify/cors": "^9.0.1",
    "@fastify/helmet": "^11.1.1",
    "@fastify/rate-limit": "^9.1.0",
    "@fastify/jwt": "^7.2.4",
    "@fastify/swagger": "^8.14.0",
    "@fastify/swagger-ui": "^1.10.0",
    "bcrypt": "^5.1.1",
    "dotenv": "^16.4.5",
    "joi": "^17.12.2",
    "jsonwebtoken": "^9.0.2",
    "pino": "^8.19.0",
    "pino-pretty": "^11.0.0"
  }},
  "devDependencies": {{
    "@types/bcrypt": "^5.0.2",
    "@types/jest": "^29.5.12",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.11.30",
    "@types/supertest": "^6.0.2",
    "@typescript-eslint/eslint-plugin": "^7.3.1",
    "@typescript-eslint/parser": "^7.3.1",
    "artillery": "^2.0.4",
    "eslint": "^8.57.0",
    "jest": "29.7.0",
    "nodemon": "^3.1.0",
    "supertest": "^6.3.4",
    "ts-jest": "29.1.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.2"
  }},
  "engines": {{
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  }}
}}'''
    
    # Removed stub package-lock.json generation - will be created by npm install
    # def _get_package_lock_json(self, project_name: str) -> str:
    #     """Generate basic package-lock.json structure."""
    #     # This was causing npm ci failures because it didn't contain actual dependency resolution
    
    def _get_tsconfig(self) -> str:
        """Generate TypeScript configuration."""
        return '''{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "tests"
  ]
}'''
    
    def _get_gitignore(self) -> str:
        """Generate .gitignore."""
        return '''# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/
jspm_packages/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build output
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Testing
test-results/
playwright-report/
coverage/

# Docker
.dockerignore
Dockerfile.local'''
    
    def _get_readme(self, project_name: str) -> str:
        """Generate README.md."""
        return f'''# {project_name}

Node.js API built with Fastify and TypeScript.

## Features

- **Fastify Framework**: High-performance web framework
- **TypeScript**: Full type safety
- **Authentication**: JWT-based auth with bcrypt
- **Validation**: Request validation with Joi
- **Security**: Helmet, CORS, rate limiting
- **Testing**: Jest with unit, integration, and security tests
- **Documentation**: Swagger/OpenAPI integration
- **Monitoring**: Structured logging with Pino

## Getting Started

```bash
# Install dependencies
npm install

# Copy environment variables
cp .env.example .env

# Start development server
npm run dev

# Build for production
npm run build
npm start
```

## API Endpoints

- `GET /` - API information
- `GET /health` - Health check
- `POST /users` - Create user
- `GET /users/:id` - Get user by ID
- `POST /auth/login` - User login
- `POST /auth/register` - User registration

## Testing

```bash
# Run all tests
npm test

# Run specific test suites
npm run test:unit          # Unit tests
npm run test:integration   # Integration tests
npm run test:security      # Security tests
npm run test:contract      # Contract tests
npm run test:load          # Load tests
npm run test:coverage      # Coverage report

# Watch mode
npm run test:watch
```

## Development

```bash
# Lint code
npm run lint
npm run lint:fix

# Type checking
npm run type-check

# Database operations
npm run db:migrate

# Generate documentation
npm run docs:generate
```

## Docker

```bash
# Build image
docker build -t {project_name} .

# Run container
docker run -p 3000:3000 {project_name}
```

## Environment Variables

See `.env.example` for required environment variables.
'''
    
    def _get_server_js(self) -> str:
        """Generate server.js entry point."""
        return '''require('dotenv').config();
const { build } = require('./src/app');

const start = async () => {
  try {
    const app = await build({
      logger: {
        level: process.env.LOG_LEVEL || 'info',
        transport: process.env.NODE_ENV === 'development' ? {
          target: 'pino-pretty',
          options: {
            translateTime: 'HH:MM:ss Z',
            ignore: 'pid,hostname',
          },
        } : undefined,
      },
    });

    const host = process.env.HOST || '0.0.0.0';
    const port = parseInt(process.env.PORT || '3000', 10);

    await app.listen({ host, port });
    console.log(`ðŸš€ Server running on http://${host}:${port}`);
  } catch (err) {
    console.error('Error starting server:', err);
    process.exit(1);
  }
};

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});

start();'''
    
    def _get_app_ts(self) -> str:
        """Generate main app configuration."""
        return '''import fastify, { FastifyInstance, FastifyPluginOptions } from 'fastify';
import helmet from '@fastify/helmet';
import cors from '@fastify/cors';
import rateLimit from '@fastify/rate-limit';
import swagger from '@fastify/swagger';
import swaggerUi from '@fastify/swagger-ui';

import { routes } from './routes';
import { config } from './utils/config';

export async function build(opts: FastifyPluginOptions = {}): Promise<FastifyInstance> {
  const app = fastify({
    logger: opts.logger || true,
    trustProxy: true,
  });

  // Register security plugins
  await app.register(helmet, {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", 'data:', 'https:'],
      },
    },
  });

  await app.register(cors, {
    origin: config.cors.origins,
    credentials: true,
  });

  await app.register(rateLimit, {
    max: 100,
    timeWindow: '1 minute',
  });

  // Register Swagger documentation
  await app.register(swagger, {
    swagger: {
      info: {
        title: 'Node.js API',
        description: 'API documentation',
        version: '1.0.0',
      },
      externalDocs: {
        url: 'https://swagger.io',
        description: 'Find more info here',
      },
      host: 'localhost:3000',
      schemes: ['http'],
      consumes: ['application/json'],
      produces: ['application/json'],
      tags: [
        { name: 'health', description: 'Health check endpoints' },
        { name: 'users', description: 'User management endpoints' },
        { name: 'auth', description: 'Authentication endpoints' },
      ],
    },
  });

  await app.register(swaggerUi, {
    routePrefix: '/docs',
    uiConfig: {
      docExpansion: 'full',
      deepLinking: false,
    },
    uiHooks: {
      onRequest: function (request, reply, next) { next(); },
      preHandler: function (request, reply, next) { next(); },
    },
    staticCSP: true,
    transformStaticCSP: (header) => header,
    transformSpecification: (swaggerObject) => swaggerObject,
    transformSpecificationClone: true,
  });

  // Register routes
  await app.register(routes);

  // Root route
  app.get('/', async (request, reply) => {
    return {
      message: 'Node.js API',
      version: '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      timestamp: new Date().toISOString(),
    };
  });

  // Health check
  app.get('/ping', async (request, reply) => {
    return { status: 'ok', timestamp: new Date().toISOString() };
  });

  return app;
}'''
    
    def _get_routes_index(self) -> str:
        """Generate routes index."""
        return '''import { FastifyInstance } from 'fastify';
import { usersRoutes } from './users';
import { healthRoutes } from './health';

export async function routes(fastify: FastifyInstance) {
  // Register route modules
  await fastify.register(healthRoutes, { prefix: '/health' });
  await fastify.register(usersRoutes, { prefix: '/users' });
}'''
    
    def _get_routes_users(self) -> str:
        """Generate users routes."""
        return '''import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { userService } from '../services/userService';
import { UserCreateSchema, UserParamsSchema } from '../models/User';

export async function usersRoutes(fastify: FastifyInstance) {
  // Get all users
  fastify.get('/', {
    schema: {
      tags: ['users'],
      summary: 'Get all users',
      response: {
        200: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              name: { type: 'string' },
              email: { type: 'string' },
              createdAt: { type: 'string' },
            },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const users = await userService.getAllUsers();
      return users;
    } catch (error) {
      fastify.log.error(error);
      reply.code(500).send({ error: 'Internal server error' });
    }
  });

  // Get user by ID
  fastify.get('/:id', {
    schema: {
      tags: ['users'],
      summary: 'Get user by ID',
      params: UserParamsSchema,
      response: {
        200: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            email: { type: 'string' },
            createdAt: { type: 'string' },
          },
        },
        404: {
          type: 'object',
          properties: {
            error: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest<{ Params: { id: string } }>, reply: FastifyReply) => {
    try {
      const { id } = request.params;
      const user = await userService.getUserById(id);
      
      if (!user) {
        return reply.code(404).send({ error: 'User not found' });
      }
      
      return user;
    } catch (error) {
      fastify.log.error(error);
      reply.code(500).send({ error: 'Internal server error' });
    }
  });

  // Create user
  fastify.post('/', {
    schema: {
      tags: ['users'],
      summary: 'Create a new user',
      body: UserCreateSchema,
      response: {
        201: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            name: { type: 'string' },
            email: { type: 'string' },
            createdAt: { type: 'string' },
          },
        },
        400: {
          type: 'object',
          properties: {
            error: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest<{ Body: { name: string; email: string; password: string } }>, reply: FastifyReply) => {
    try {
      const { name, email, password } = request.body;
      const user = await userService.createUser({ name, email, password });
      
      reply.code(201).send(user);
    } catch (error: any) {
      fastify.log.error(error);
      
      if (error.message.includes('already exists')) {
        return reply.code(400).send({ error: error.message });
      }
      
      reply.code(500).send({ error: 'Internal server error' });
    }
  });
}'''
    
    def _get_routes_health(self) -> str:
        """Generate health routes."""
        return '''import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';

export async function healthRoutes(fastify: FastifyInstance) {
  // Basic health check
  fastify.get('/', {
    schema: {
      tags: ['health'],
      summary: 'Basic health check',
      response: {
        200: {
          type: 'object',
          properties: {
            status: { type: 'string' },
            timestamp: { type: 'string' },
            uptime: { type: 'number' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    };
  });

  // Detailed health check
  fastify.get('/detailed', {
    schema: {
      tags: ['health'],
      summary: 'Detailed health check',
      response: {
        200: {
          type: 'object',
          properties: {
            status: { type: 'string' },
            timestamp: { type: 'string' },
            uptime: { type: 'number' },
            memory: { type: 'object' },
            version: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const memoryUsage = process.memoryUsage();
    
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: {
        rss: `${Math.round(memoryUsage.rss / 1024 / 1024)} MB`,
        heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)} MB`,
        heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)} MB`,
        external: `${Math.round(memoryUsage.external / 1024 / 1024)} MB`,
      },
      version: process.env.npm_package_version || '1.0.0',
    };
  });
}'''
    
    def _get_middleware_auth(self) -> str:
        """Generate auth middleware."""
        return '''import { FastifyRequest, FastifyReply } from 'fastify';
import jwt from 'jsonwebtoken';
import { config } from '../utils/config';

export interface AuthenticatedRequest extends FastifyRequest {
  user?: {
    id: string;
    email: string;
  };
}

export async function authenticateToken(request: AuthenticatedRequest, reply: FastifyReply) {
  try {
    const authHeader = request.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      return reply.code(401).send({ error: 'Access token required' });
    }

    const decoded = jwt.verify(token, config.jwt.secret) as any;
    request.user = { id: decoded.id, email: decoded.email };
  } catch (error) {
    return reply.code(403).send({ error: 'Invalid or expired token' });
  }
}

export function requireAuth() {
  return authenticateToken;
}'''
    
    def _get_middleware_cors(self) -> str:
        """Generate CORS middleware."""
        return '''import { FastifyRequest, FastifyReply } from 'fastify';

export async function corsMiddleware(request: FastifyRequest, reply: FastifyReply) {
  const allowedOrigins = [
    'http://localhost:3000',
    'http://localhost:3001',
    'https://yourapp.com',
  ];

  const origin = request.headers.origin;
  
  if (origin && allowedOrigins.includes(origin)) {
    reply.header('Access-Control-Allow-Origin', origin);
  }
  
  reply.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
  reply.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With');
  reply.header('Access-Control-Allow-Credentials', 'true');

  if (request.method === 'OPTIONS') {
    reply.code(200).send();
    return;
  }
}'''
    
    def _get_middleware_validation(self) -> str:
        """Generate validation middleware."""
        return '''import Joi from 'joi';
import { FastifyRequest, FastifyReply } from 'fastify';

export function validateBody(schema: Joi.ObjectSchema) {
  return async function(request: FastifyRequest, reply: FastifyReply) {
    try {
      const { error, value } = schema.validate(request.body);
      
      if (error) {
        return reply.code(400).send({
          error: 'Validation error',
          details: error.details.map(detail => ({
            field: detail.path.join('.'),
            message: detail.message,
          })),
        });
      }
      
      request.body = value;
    } catch (error) {
      return reply.code(400).send({ error: 'Invalid request body' });
    }
  };
}

export function validateParams(schema: Joi.ObjectSchema) {
  return async function(request: FastifyRequest, reply: FastifyReply) {
    try {
      const { error, value } = schema.validate(request.params);
      
      if (error) {
        return reply.code(400).send({
          error: 'Validation error',
          details: error.details.map(detail => ({
            field: detail.path.join('.'),
            message: detail.message,
          })),
        });
      }
      
      request.params = value;
    } catch (error) {
      return reply.code(400).send({ error: 'Invalid request parameters' });
    }
  };
}

export function validateQuery(schema: Joi.ObjectSchema) {
  return async function(request: FastifyRequest, reply: FastifyReply) {
    try {
      const { error, value } = schema.validate(request.query);
      
      if (error) {
        return reply.code(400).send({
          error: 'Validation error',
          details: error.details.map(detail => ({
            field: detail.path.join('.'),
            message: detail.message,
          })),
        });
      }
      
      request.query = value;
    } catch (error) {
      return reply.code(400).send({ error: 'Invalid query parameters' });
    }
  };
}'''
    
    def _get_user_service(self) -> str:
        """Generate user service."""
        return '''import bcrypt from 'bcrypt';
import { User, CreateUserData } from '../models/User';

// In-memory store for demo purposes
// In a real app, this would be a database
class UserStore {
  private users: User[] = [];
  private nextId = 1;

  async create(data: CreateUserData): Promise<User> {
    // Check if user already exists
    const existingUser = this.users.find(u => u.email === data.email);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(data.password, 10);

    const user: User = {
      id: this.nextId.toString(),
      name: data.name,
      email: data.email,
      password: hashedPassword,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.users.push(user);
    this.nextId++;

    // Return user without password
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
  }

  async findById(id: string): Promise<User | null> {
    const user = this.users.find(u => u.id === id);
    if (!user) return null;

    // Return user without password
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
  }

  async findByEmail(email: string): Promise<User | null> {
    const user = this.users.find(u => u.email === email);
    if (!user) return null;

    // Return user without password
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
  }

  async findAll(): Promise<User[]> {
    // Return users without passwords
    return this.users.map(({ password, ...user }) => user as User);
  }

  async validatePassword(email: string, password: string): Promise<User | null> {
    const user = this.users.find(u => u.email === email);
    if (!user) return null;

    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) return null;

    // Return user without password
    const { password: _, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
  }
}

class UserService {
  private store = new UserStore();

  async createUser(data: CreateUserData): Promise<User> {
    return this.store.create(data);
  }

  async getUserById(id: string): Promise<User | null> {
    return this.store.findById(id);
  }

  async getUserByEmail(email: string): Promise<User | null> {
    return this.store.findByEmail(email);
  }

  async getAllUsers(): Promise<User[]> {
    return this.store.findAll();
  }

  async validateUser(email: string, password: string): Promise<User | null> {
    return this.store.validatePassword(email, password);
  }
}

export const userService = new UserService();'''
    
    def _get_user_model(self) -> str:
        """Generate User model."""
        return '''export interface User {
  id: string;
  name: string;
  email: string;
  password?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserData {
  name: string;
  email: string;
  password: string;
}

export const UserCreateSchema = {
  type: 'object',
  required: ['name', 'email', 'password'],
  properties: {
    name: {
      type: 'string',
      minLength: 2,
      maxLength: 50,
    },
    email: {
      type: 'string',
      format: 'email',
      maxLength: 100,
    },
    password: {
      type: 'string',
      minLength: 6,
      maxLength: 100,
    },
  },
};

export const UserParamsSchema = {
  type: 'object',
  required: ['id'],
  properties: {
    id: {
      type: 'string',
      pattern: '^[0-9]+$',
    },
  },
};'''
    
    def _get_types(self) -> str:
        """Generate type definitions."""
        return '''// Common type definitions

export interface ApiResponse<T> {
  data?: T;
  message?: string;
  error?: string;
}

export interface PaginationQuery {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

export type Environment = 'development' | 'test' | 'production';

export interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
}

export interface JWTPayload {
  id: string;
  email: string;
  iat?: number;
  exp?: number;
}'''
    
    def _get_logger(self) -> str:
        """Generate logger utility."""
        return '''import pino from 'pino';

const isDevelopment = process.env.NODE_ENV === 'development';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: isDevelopment ? {
    target: 'pino-pretty',
    options: {
      translateTime: 'HH:MM:ss Z',
      ignore: 'pid,hostname',
    },
  } : undefined,
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    },
  },
  timestamp: pino.stdTimeFunctions.isoTime,
});

// Create child loggers for different modules
export const createLogger = (module: string) => {
  return logger.child({ module });
};

export default logger;'''
    
    def _get_config(self) -> str:
        """Generate configuration utility."""
        return '''import dotenv from 'dotenv';

dotenv.config();

interface Config {
  port: number;
  host: string;
  nodeEnv: string;
  cors: {
    origins: string[];
  };
  jwt: {
    secret: string;
    expiresIn: string;
  };
  bcrypt: {
    rounds: number;
  };
  rateLimit: {
    max: number;
    timeWindow: string;
  };
}

export const config: Config = {
  port: parseInt(process.env.PORT || '3000', 10),
  host: process.env.HOST || '0.0.0.0',
  nodeEnv: process.env.NODE_ENV || 'development',
  cors: {
    origins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production',
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
  },
  bcrypt: {
    rounds: parseInt(process.env.BCRYPT_ROUNDS || '10', 10),
  },
  rateLimit: {
    max: parseInt(process.env.RATE_LIMIT_MAX || '100', 10),
    timeWindow: process.env.RATE_LIMIT_WINDOW || '1 minute',
  },
};

// Validate required environment variables
const requiredEnvVars = ['JWT_SECRET'];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar] && config.nodeEnv === 'production') {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

export default config;'''
    
    def _get_database(self) -> str:
        """Generate database utility."""
        return '''// Database connection and utilities
// This is a placeholder for database integration

export class Database {
  private static instance: Database;
  private connected = false;

  private constructor() {}

  public static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }

  async connect(): Promise<void> {
    if (this.connected) {
      return;
    }

    try {
      // Database connection logic would go here
      // For example: await mongoose.connect(connectionString);
      
      console.log('Database connected successfully');
      this.connected = true;
    } catch (error) {
      console.error('Database connection failed:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    if (!this.connected) {
      return;
    }

    try {
      // Database disconnection logic would go here
      // For example: await mongoose.disconnect();
      
      console.log('Database disconnected successfully');
      this.connected = false;
    } catch (error) {
      console.error('Database disconnection failed:', error);
      throw error;
    }
  }

  isConnected(): boolean {
    return this.connected;
  }
}

export const database = Database.getInstance();'''
    
    def _get_user_service_test(self) -> str:
        """Generate user service test."""
        return '''const { userService } = require('../../src/services/userService');

describe('UserService', () => {
  beforeEach(() => {
    // Reset user store before each test
    userService.store = new (require('../../src/services/userService').UserStore)();
  });

  describe('createUser', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const user = await userService.createUser(userData);

      expect(user).toBeDefined();
      expect(user.name).toBe(userData.name);
      expect(user.email).toBe(userData.email);
      expect(user.password).toBeUndefined(); // Password should not be returned
      expect(user.id).toBeDefined();
      expect(user.createdAt).toBeDefined();
    });

    it('should not create user with duplicate email', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      await userService.createUser(userData);

      await expect(userService.createUser(userData))
        .rejects
        .toThrow('User with this email already exists');
    });
  });

  describe('getUserById', () => {
    it('should return user by id', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const createdUser = await userService.createUser(userData);
      const foundUser = await userService.getUserById(createdUser.id);

      expect(foundUser).toBeDefined();
      expect(foundUser.id).toBe(createdUser.id);
      expect(foundUser.email).toBe(userData.email);
    });

    it('should return null for non-existent user', async () => {
      const foundUser = await userService.getUserById('999');
      expect(foundUser).toBeNull();
    });
  });

  describe('validateUser', () => {
    it('should validate user with correct password', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      await userService.createUser(userData);
      const validatedUser = await userService.validateUser(userData.email, userData.password);

      expect(validatedUser).toBeDefined();
      expect(validatedUser.email).toBe(userData.email);
    });

    it('should not validate user with incorrect password', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      await userService.createUser(userData);
      const validatedUser = await userService.validateUser(userData.email, 'wrongpassword');

      expect(validatedUser).toBeNull();
    });
  });
});'''
    
    def _get_middleware_test(self) -> str:
        """Generate middleware test."""
        return '''const { authenticateToken } = require('../../src/middleware/auth');
const jwt = require('jsonwebtoken');

describe('Authentication Middleware', () => {
  let mockRequest;
  let mockReply;

  beforeEach(() => {
    mockRequest = {
      headers: {}
    };
    
    mockReply = {
      code: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };
  });

  describe('authenticateToken', () => {
    it('should authenticate valid token', async () => {
      const token = jwt.sign(
        { id: '1', email: 'test@example.com' },
        process.env.JWT_SECRET || 'test-secret'
      );

      mockRequest.headers.authorization = `Bearer ${token}`;

      await authenticateToken(mockRequest, mockReply);

      expect(mockRequest.user).toBeDefined();
      expect(mockRequest.user.id).toBe('1');
      expect(mockRequest.user.email).toBe('test@example.com');
      expect(mockReply.code).not.toHaveBeenCalled();
    });

    it('should reject request without token', async () => {
      await authenticateToken(mockRequest, mockReply);

      expect(mockReply.code).toHaveBeenCalledWith(401);
      expect(mockReply.send).toHaveBeenCalledWith({
        error: 'Access token required'
      });
    });

    it('should reject invalid token', async () => {
      mockRequest.headers.authorization = 'Bearer invalid-token';

      await authenticateToken(mockRequest, mockReply);

      expect(mockReply.code).toHaveBeenCalledWith(403);
      expect(mockReply.send).toHaveBeenCalledWith({
        error: 'Invalid or expired token'
      });
    });
  });
});'''
    
    def _get_users_integration_test(self) -> str:
        """Generate users integration test."""
        return '''const { build } = require('../../src/app');
const supertest = require('supertest');

describe('Users API Integration Tests', () => {
  let app;

  beforeAll(async () => {
    app = await build({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('GET /users', () => {
    it('should return empty array initially', async () => {
      const response = await supertest(app.server)
        .get('/users')
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0);
    });
  });

  describe('POST /users', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const response = await supertest(app.server)
        .post('/users')
        .send(userData)
        .expect(201);

      expect(response.body).toBeDefined();
      expect(response.body.name).toBe(userData.name);
      expect(response.body.email).toBe(userData.email);
      expect(response.body.password).toBeUndefined();
      expect(response.body.id).toBeDefined();
    });

    it('should validate required fields', async () => {
      const response = await supertest(app.server)
        .post('/users')
        .send({})
        .expect(400);

      expect(response.body.error).toBeDefined();
    });

    it('should validate email format', async () => {
      const userData = {
        name: 'John Doe',
        email: 'invalid-email',
        password: 'password123'
      };

      const response = await supertest(app.server)
        .post('/users')
        .send(userData)
        .expect(400);

      expect(response.body.error).toBeDefined();
    });
  });

  describe('GET /users/:id', () => {
    let userId;

    beforeEach(async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const response = await supertest(app.server)
        .post('/users')
        .send(userData);

      userId = response.body.id;
    });

    it('should return user by id', async () => {
      const response = await supertest(app.server)
        .get(`/users/${userId}`)
        .expect(200);

      expect(response.body).toBeDefined();
      expect(response.body.id).toBe(userId);
    });

    it('should return 404 for non-existent user', async () => {
      const response = await supertest(app.server)
        .get('/users/999')
        .expect(404);

      expect(response.body.error).toBe('User not found');
    });
  });
});'''
    
    def _get_health_integration_test(self) -> str:
        """Generate health integration test."""
        return '''const { build } = require('../../src/app');
const supertest = require('supertest');

describe('Health Check Integration Tests', () => {
  let app;

  beforeAll(async () => {
    app = await build({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('GET /health', () => {
    it('should return health status', async () => {
      const response = await supertest(app.server)
        .get('/health')
        .expect(200);

      expect(response.body).toBeDefined();
      expect(response.body.status).toBe('healthy');
      expect(response.body.timestamp).toBeDefined();
      expect(response.body.uptime).toBeDefined();
    });
  });

  describe('GET /health/detailed', () => {
    it('should return detailed health information', async () => {
      const response = await supertest(app.server)
        .get('/health/detailed')
        .expect(200);

      expect(response.body).toBeDefined();
      expect(response.body.status).toBe('healthy');
      expect(response.body.timestamp).toBeDefined();
      expect(response.body.uptime).toBeDefined();
      expect(response.body.memory).toBeDefined();
      expect(response.body.version).toBeDefined();
    });
  });

  describe('GET /ping', () => {
    it('should return pong', async () => {
      const response = await supertest(app.server)
        .get('/ping')
        .expect(200);

      expect(response.body.status).toBe('ok');
      expect(response.body.timestamp).toBeDefined();
    });
  });
});'''
    
    def _get_auth_security_test(self) -> str:
        """Generate auth security test."""
        return '''const { build } = require('../../src/app');
const supertest = require('supertest');
const jwt = require('jsonwebtoken');

describe('Security Tests', () => {
  let app;

  beforeAll(async () => {
    app = await build({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('Rate Limiting', () => {
    it('should apply rate limiting', async () => {
      const promises = [];
      
      // Make 101 requests (limit is 100 per minute)
      for (let i = 0; i < 101; i++) {
        promises.push(
          supertest(app.server)
            .get('/ping')
        );
      }

      const responses = await Promise.all(promises);
      const rateLimitedResponses = responses.filter(res => res.status === 429);

      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    }, 10000);
  });

  describe('CORS Headers', () => {
    it('should include CORS headers', async () => {
      const response = await supertest(app.server)
        .get('/ping')
        .expect(200);

      expect(response.headers['access-control-allow-origin']).toBeDefined();
    });
  });

  describe('Security Headers', () => {
    it('should include security headers', async () => {
      const response = await supertest(app.server)
        .get('/ping')
        .expect(200);

      expect(response.headers['x-content-type-options']).toBe('nosniff');
      expect(response.headers['x-frame-options']).toBeDefined();
      expect(response.headers['x-xss-protection']).toBeDefined();
    });
  });

  describe('JWT Token Security', () => {
    it('should reject expired tokens', async () => {
      const expiredToken = jwt.sign(
        { id: '1', email: 'test@example.com' },
        process.env.JWT_SECRET || 'test-secret',
        { expiresIn: '-1h' } // Already expired
      );

      // This would be tested on protected routes if they existed
      expect(expiredToken).toBeDefined();
    });

    it('should reject malformed tokens', async () => {
      const malformedToken = 'invalid.token.here';

      // This would be tested on protected routes if they existed
      expect(malformedToken).toBeDefined();
    });
  });

  describe('Input Validation', () => {
    it('should validate email format', async () => {
      const response = await supertest(app.server)
        .post('/users')
        .send({
          name: 'Test User',
          email: 'invalid-email-format',
          password: 'password123'
        })
        .expect(400);

      expect(response.body.error).toBeDefined();
    });

    it('should validate required fields', async () => {
      const response = await supertest(app.server)
        .post('/users')
        .send({})
        .expect(400);

      expect(response.body.error).toBeDefined();
    });
  });
});'''
    
    def _get_users_contract_test(self) -> str:
        """Generate users contract test."""
        return '''const { build } = require('../../src/app');
const supertest = require('supertest');

describe('Users API Contract Tests', () => {
  let app;

  beforeAll(async () => {
    app = await build({ logger: false });
    await app.ready();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('User Creation Contract', () => {
    it('should match expected response schema for POST /users', async () => {
      const userData = {
        name: 'Contract Test User',
        email: 'contract@example.com',
        password: 'password123'
      };

      const response = await supertest(app.server)
        .post('/users')
        .send(userData)
        .expect(201);

      // Verify response schema
      expect(response.body).toHaveProperty('id');
      expect(response.body).toHaveProperty('name');
      expect(response.body).toHaveProperty('email');
      expect(response.body).toHaveProperty('createdAt');
      
      // Verify types
      expect(typeof response.body.id).toBe('string');
      expect(typeof response.body.name).toBe('string');
      expect(typeof response.body.email).toBe('string');
      expect(typeof response.body.createdAt).toBe('string');
      
      // Verify password is not included
      expect(response.body).not.toHaveProperty('password');
      
      // Verify values
      expect(response.body.name).toBe(userData.name);
      expect(response.body.email).toBe(userData.email);
    });
  });

  describe('User Retrieval Contract', () => {
    let userId;

    beforeEach(async () => {
      const userData = {
        name: 'Contract Test User',
        email: 'contract2@example.com',
        password: 'password123'
      };

      const response = await supertest(app.server)
        .post('/users')
        .send(userData);

      userId = response.body.id;
    });

    it('should match expected response schema for GET /users/:id', async () => {
      const response = await supertest(app.server)
        .get(`/users/${userId}`)
        .expect(200);

      // Verify response schema
      expect(response.body).toHaveProperty('id');
      expect(response.body).toHaveProperty('name');
      expect(response.body).toHaveProperty('email');
      expect(response.body).toHaveProperty('createdAt');
      
      // Verify types
      expect(typeof response.body.id).toBe('string');
      expect(typeof response.body.name).toBe('string');
      expect(typeof response.body.email).toBe('string');
      expect(typeof response.body.createdAt).toBe('string');
      
      // Verify password is not included
      expect(response.body).not.toHaveProperty('password');
    });

    it('should match expected error schema for GET /users/:id (not found)', async () => {
      const response = await supertest(app.server)
        .get('/users/999')
        .expect(404);

      // Verify error response schema
      expect(response.body).toHaveProperty('error');
      expect(typeof response.body.error).toBe('string');
      expect(response.body.error).toBe('User not found');
    });
  });

  describe('User List Contract', () => {
    it('should match expected response schema for GET /users', async () => {
      const response = await supertest(app.server)
        .get('/users')
        .expect(200);

      // Verify response is an array
      expect(Array.isArray(response.body)).toBe(true);

      // If there are users, verify their schema
      if (response.body.length > 0) {
        const user = response.body[0];
        expect(user).toHaveProperty('id');
        expect(user).toHaveProperty('name');
        expect(user).toHaveProperty('email');
        expect(user).toHaveProperty('createdAt');
        expect(user).not.toHaveProperty('password');
      }
    });
  });
});'''
    
    def _get_load_test_config(self) -> str:
        """Generate load test configuration."""
        return '''config:
  target: "http://localhost:3000"
  phases:
    - duration: 60
      arrivalRate: 10
      name: "Warm up"
    - duration: 120
      arrivalRate: 50
      name: "Load test"
    - duration: 60
      arrivalRate: 100
      name: "Stress test"
  defaults:
    headers:
      Content-Type: "application/json"

scenarios:
  - name: "Health check load test"
    weight: 30
    flow:
      - get:
          url: "/health"
      - get:
          url: "/ping"

  - name: "User creation load test"
    weight: 70
    flow:
      - post:
          url: "/users"
          json:
            name: "Load Test User {{ $uuid }}"
            email: "loadtest{{ $uuid }}@example.com"
            password: "password123"
        capture:
          - json: "$.id"
            as: "userId"
      - get:
          url: "/users/{{ userId }}"

plugins:
  expect: {}

config:
  ensure:
    thresholds:
      - http.response_time.p95: 500
      - http.response_time.p99: 1000
      - http.request_rate: 50'''
    
    def _get_jest_config(self) -> str:
        """Generate Jest configuration."""
        return '''module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/*.(test|spec).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.{js,ts}',
    '!src/**/*.d.ts',
    '!src/types/**/*',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: [
    'text',
    'lcov',
    'html'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testTimeout: 10000,
  verbose: true,
  forceExit: true,
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true
};'''
    
    def _get_dockerfile(self) -> str:
        """Generate Dockerfile."""
        return '''FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Build the application
FROM base AS builder
WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Install all dependencies (including dev dependencies)
RUN npm ci

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production

# Create a non-root user
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nodejs

# Copy the built application
COPY --from=builder /app/dist ./dist
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json
COPY --from=builder /app/server.js ./server.js

# Change ownership to nodejs user
RUN chown -R nodejs:nodejs /app
USER nodejs

# Expose the port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node -e "require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["node", "server.js"]'''
    
    def _get_dockerignore(self) -> str:
        """Generate .dockerignore."""
        return '''node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.nyc_output
coverage
.vscode
.idea
*.swp
*.swo
.DS_Store
tests
jest.config.js
.eslintrc.js
.prettierrc
*.test.js
*.test.ts
*.spec.js
*.spec.ts'''
    
    def _get_env_example(self) -> str:
        """Generate .env.example."""
        return '''# Server Configuration
NODE_ENV=development
HOST=0.0.0.0
PORT=3000
LOG_LEVEL=info

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=24h

# CORS Configuration
CORS_ORIGINS=http://localhost:3000,http://localhost:3001

# BCrypt Configuration
BCRYPT_ROUNDS=10

# Rate Limiting
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW=1 minute

# Database Configuration (if using a database)
# DATABASE_URL=postgresql://username:password@localhost:5432/database_name
# REDIS_URL=redis://localhost:6379

# Third-party API Keys (if needed)
# API_KEY=your-api-key-here'''